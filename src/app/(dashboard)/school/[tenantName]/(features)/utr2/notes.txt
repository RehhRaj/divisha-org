Promise.all([
  handleFileCompact(compFile),
  handleFileUTR(utrFile)
]);


******************************

Common Real-Life Example: Reading a File

const readFile = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject("Failed to read file");

    reader.readAsText(file);
  });
};

******************************

Async/Await (modern way to use Promises)

const doSomething = async () => {
  try {
    const result = await orderFood;
    console.log("‚úÖ", result);
  } catch (error) {
    console.log("‚ùå", error);
  }
};

doSomething();

******************************


| Term          | Meaning                                  |
| ------------- | ---------------------------------------- |
| `Promise`     | A placeholder for future data            |
| `resolve()`   | Call this when async task succeeds       |
| `reject()`    | Call this when async task fails          |
| `.then()`     | Handle success                           |
| `.catch()`    | Handle error                             |
| `async/await` | Cleaner syntax for working with promises |


*******************************
üß† Think of it like...
Real-world	Code equivalent
Zomato order	new Promise(...)
Food delivered	resolve()
Food canceled	reject()
Customer gets food	.then()
Customer complains	.catch()

***********************************

smple code
-------------------------mple codes 
A shared/common logic for both file types (compact and UTR)

File processing to happen asynchronously and independently (i.e., user can upload one file without waiting for the other)

A Promise-based structure for clean async flow

Final step: generate different reports based on file type

üß† Should You Use Promise?

‚úÖ Yes, but use them with async/await ‚Äî it's much cleaner and readable in TypeScript + Next.js apps.

You are:

Doing async file reading (FileReader)

Doing async parsing logic

Processing multiple files independently

So, using Promise (or better, async/await) is the recommended approach. ---------------------------



---------------üß™ How this solves your use case:
‚úÖ Requirement	üí° Solution
Process files independently	Each onFileSelect runs on its own, async
Common logic	Extracted into parseFileCommonSteps()
Different logic	Separated in handleFileUTR() and handleFileCompact()
Reusability	Easily add more file types later
Promise functionality	Fully based on Promise / async-await----------------

*************************

// utils/file-utils.ts
export interface ParsedFile {
  rawLines: string[];
  headerLines: string[];
  dataLines: string[];
}

export const parseFileCommonSteps = (file: File): Promise<ParsedFile> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = () => {
      const content = reader.result as string;
      const lines = content.split('\n').map(line => line.trim()).filter(Boolean);

      // Logic: detect header vs data rows
      let headerLineCount = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].toLowerCase().includes('amount') || lines[i].toLowerCase().includes('utr')) {
          headerLineCount = i;
          break;
        }
      }

      const headerLines = lines.slice(0, headerLineCount);
      const dataLines = lines.slice(headerLineCount);

      resolve({
        rawLines: lines,
        headerLines,
        dataLines
      });
    };

    reader.onerror = () => {
      reject("Failed to read file");
    };

    reader.readAsText(file);
  });
};

************************
// utils/handle-utr-file.ts
import { parseFileCommonSteps, ParsedFile } from './file-utils';

export const handleFileUTR = async (file: File): Promise<any> => {
  const parsed = await parseFileCommonSteps(file);

  // Example: UTR-specific parsing
  const report = parsed.dataLines.map((line, index) => {
    const columns = line.split(',');
    return {
      lineNo: index + 1,
      utr: columns[2]?.trim(),
      amount: columns[3]?.trim(),
    };
  });

  return report;
};

*********************
// utils/handle-compact-file.ts
import { parseFileCommonSteps, ParsedFile } from './file-utils';

export const handleFileCompact = async (file: File): Promise<any> => {
  const parsed = await parseFileCommonSteps(file);

  // Example: compact-specific parsing
  const report = parsed.dataLines.map((line, index) => {
    const columns = line.split(',');
    return {
      lineNo: index + 1,
      date: columns[0]?.trim(),
      amount: columns[1]?.trim(),
      type: columns[2]?.trim(),
    };
  });

  return report;
};

**********************
<FileSelector label="Upload comp file" onFileSelect={handleFileCompact} />
<FileSelector label="Upload UTR file" onFileSelect={handleFileUTR} />

*************

// components/FileSelector.tsx
import React from 'react';

interface Props {
  label: string;
  onFileSelect: (file: File) => Promise<any>;
}

const FileSelector: React.FC<Props> = ({ label, onFileSelect }) => {
  const handleChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      const result = await onFileSelect(file);
      console.log("Processed Data:", result);
    } catch (err) {
      console.error("Error processing file:", err);
    }
  };

  return (
    <div>
      <label>{label}</label>
      <input type="file" onChange={handleChange} />
    </div>
  );
};

export default FileSelector;

***********************
//  frontend/src/app/(dashboard)/school/[tenantName]/(features)/utr2/op-flow.client.tsx

'use client';

import React, { useState } from 'react';
import FileSelector from '@/components/FileSelector'; // Update the path as needed
import { handleFileCompact } from '@/utils/handle-compact-file';
import { handleFileUTR } from '@/utils/handle-utr-file';

export default function FileUploadFlow() {
  const [compactReport, setCompactReport] = useState<any[] | null>(null);
  const [utrReport, setUtrReport] = useState<any[] | null>(null);

  const handleCompactUpload = async (file: File) => {
    try {
      const data = await handleFileCompact(file);
      setCompactReport(data);
      console.log('‚úÖ Compact File Processed:', data);
    } catch (err) {
      console.error('‚ùå Error processing compact file:', err);
    }
  };

  const handleUtrUpload = async (file: File) => {
    try {
      const data = await handleFileUTR(file);
      setUtrReport(data);
      console.log('‚úÖ UTR File Processed:', data);
    } catch (err) {
      console.error('‚ùå Error processing UTR file:', err);
    }
  };

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-xl font-bold">Excel Upload Report</h1>

      <FileSelector label="Upload comp file" onFileSelect={handleCompactUpload} />
      <FileSelector label="Upload UTR file" onFileSelect={handleUtrUpload} />

      {/* Optional: Show results */}
      {compactReport && (
        <div>
          <h2 className="font-semibold mt-4">üìÑ Compact Report</h2>
          <pre className="bg-gray-100 p-2 rounded text-sm overflow-x-auto">
            {JSON.stringify(compactReport, null, 2)}
          </pre>
        </div>
      )}

      {utrReport && (
        <div>
          <h2 className="font-semibold mt-4">üìÑ UTR Report</h2>
          <pre className="bg-gray-100 p-2 rounded text-sm overflow-x-auto">
            {JSON.stringify(utrReport, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
}


**********************

‚úÖ Supporting Components and Files
1. components/FileSelector.tsx


//components/FileSelector.tsx
'use client';

import React from 'react';

interface Props {
  label: string;
  onFileSelect: (file: File) => Promise<void>;
}

const FileSelector: React.FC<Props> = ({ label, onFileSelect }) => {
  const handleChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    await onFileSelect(file);
    e.target.value = ''; // Reset file input for same file re-upload
  };

  return (
    <div className="mb-4">
      <label className="block font-medium mb-1">{label}</label>
      <input type="file" onChange={handleChange} className="border p-2" />
    </div>
  );
};

export default FileSelector;


------------------------ page.tsx  <-- FileUploadFlow (as above)

/components
  FileSelector.tsx

/utils
  file-utils.ts           <-- parseFileCommonSteps
  handle-utr-file.ts      <-- handleFileUTR
  handle-compact-file.ts  <-- handleFileCompact

üöÄ What this gives you:

    Users can upload both files independently

    Each file uses shared logic (parseFileCommonSteps)

    Resulting reports are stored and displayed

    The UI is responsive to both success and failure

    You can easily build on top ‚Äî show tables, download reports, etc.

Let me know if you'd like:

    Table rendering instead of <pre>

    File type validation (CSV, XLSX, etc.)

    Tailwind styling (if you're using it)

    Drag-and-drop support

Happy building! -------------------------

****************************

üìÅ Files to Keep (And Why)
‚úÖ File	‚úÖ Why Keep It
fileuploadflow.tsx	‚úÖ This is your core feature logic (uploading compact + UTR). Rename to FileUploadFlow.tsx and move under flows/ or components/.
op-flow.client.tsx	‚úÖ This is your user-facing UI (likely a page or wrapper). Good placement.
page.tsx	‚úÖ This is your Next.js route entry ‚Äî it‚Äôs the right place.
components/export-button.tsx	‚úÖ UI component ‚Äî keep
components/file-selector.tsx	‚úÖ Reusable input component ‚Äî keep
components/report.tsx	‚úÖ Table or data output UI ‚Äî keep
components/upload-complete-message.tsx	‚úÖ Status component ‚Äî keep
components/upload-progress-bar.tsx	‚úÖ Progress UI ‚Äî keep
components/utils/parsers.ts	‚úÖ Central place to define specific parsing logic per file type
components/utils/process-file-upload.ts	‚úÖ Shared utility for file reading, parsing
components/utils/validators.ts (if needed)	‚úÖ For file size/type checking